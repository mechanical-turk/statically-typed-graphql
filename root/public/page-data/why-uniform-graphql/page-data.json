{"componentChunkName":"component---node-modules-rocketseat-gatsby-theme-docs-core-src-templates-docs-query-js","path":"/why-uniform-graphql","result":{"data":{"mdx":{"id":"3a72aa8c-7c1b-5991-a720-aa4f6a7737f7","excerpt":"tl;dr: Type-safety is concerned with compile time whereas GraphQL schemas are concerned with runtime. What we need is a  uniform  approach that is type-safe atâ€¦","fields":{"slug":"/why-uniform-graphql/"},"frontmatter":{"title":"Why UniformGraphQL","description":"Learn how to create docs using Rocket Docs.","image":null,"disableTableOfContents":null},"body":"function _extends() { _extends = Object.assign || function (target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i]; for (var key in source) { if (Object.prototype.hasOwnProperty.call(source, key)) { target[key] = source[key]; } } } return target; }; return _extends.apply(this, arguments); }\n\nfunction _objectWithoutProperties(source, excluded) { if (source == null) return {}; var target = _objectWithoutPropertiesLoose(source, excluded); var key, i; if (Object.getOwnPropertySymbols) { var sourceSymbolKeys = Object.getOwnPropertySymbols(source); for (i = 0; i < sourceSymbolKeys.length; i++) { key = sourceSymbolKeys[i]; if (excluded.indexOf(key) >= 0) continue; if (!Object.prototype.propertyIsEnumerable.call(source, key)) continue; target[key] = source[key]; } } return target; }\n\nfunction _objectWithoutPropertiesLoose(source, excluded) { if (source == null) return {}; var target = {}; var sourceKeys = Object.keys(source); var key, i; for (i = 0; i < sourceKeys.length; i++) { key = sourceKeys[i]; if (excluded.indexOf(key) >= 0) continue; target[key] = source[key]; } return target; }\n\n/* @jsxRuntime classic */\n\n/* @jsx mdx */\nvar _frontmatter = {\n  \"title\": \"Why UniformGraphQL\",\n  \"description\": \"Learn how to create docs using Rocket Docs.\"\n};\nvar layoutProps = {\n  _frontmatter: _frontmatter\n};\nvar MDXLayout = \"wrapper\";\nreturn function MDXContent(_ref) {\n  var components = _ref.components,\n      props = _objectWithoutProperties(_ref, [\"components\"]);\n\n  return mdx(MDXLayout, _extends({}, layoutProps, props, {\n    components: components,\n    mdxType: \"MDXLayout\"\n  }), mdx(\"blockquote\", null, mdx(\"p\", {\n    parentName: \"blockquote\"\n  }, \"tl;dr: Type-safety is concerned with compile time whereas GraphQL schemas are concerned with runtime. What we need is a \", mdx(\"strong\", {\n    parentName: \"p\"\n  }, \"uniform\"), \" approach that is type-safe at compile time while preserving a runtime type information that carries smoothly to GraphQL schemas. And that's what \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"uniform-graphql\"), \" is all about: Helping you build code-first GraphQL schemas by delegating all forms of type-safety to the compiler.\")), mdx(\"h2\", {\n    \"id\": \"motivation\",\n    \"style\": {\n      \"position\": \"relative\"\n    }\n  }, mdx(\"a\", {\n    parentName: \"h2\",\n    \"href\": \"#motivation\",\n    \"aria-label\": \"motivation permalink\",\n    \"className\": \"anchor before\"\n  }, mdx(\"svg\", {\n    parentName: \"a\",\n    \"aria-hidden\": \"true\",\n    \"focusable\": \"false\",\n    \"height\": \"16\",\n    \"version\": \"1.1\",\n    \"viewBox\": \"0 0 16 16\",\n    \"width\": \"16\"\n  }, mdx(\"path\", {\n    parentName: \"svg\",\n    \"fillRule\": \"evenodd\",\n    \"d\": \"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"\n  }))), \"Motivation\"), mdx(\"p\", null, \"GraphQL apis usually fall under two schools of thought: \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"schema-first\"), \" vs \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"code-first\"), \". Schema-first GraphQL apis create the typedefs first - including all queries, mutations and subscriptions - and implement the corresponding resolvers after. Code-first apis on the other hand implement the resolvers first and have the typedefs derived from the code. Both approaches have their pros and cons. \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"uniform-graphql\"), \" falls somewhere in the middle, but it's closer to the code-first camp.\"), mdx(\"p\", null, \"The biggest issue with the currently available code-first approaches emerges during the schema-generation phase: a non-trivial mismatch between the implemented resolvers and the generated schema. Developers can't simply rely on the compiler to make sure that their code will match the generated schema, so they have to resort to other means such as decorators and other runtime checks. But it doesn't have to be that way. As it turns out, this is a perfect job for the compiler.\"), mdx(\"h2\", {\n    \"id\": \"end-to-end-type-safety\",\n    \"style\": {\n      \"position\": \"relative\"\n    }\n  }, mdx(\"a\", {\n    parentName: \"h2\",\n    \"href\": \"#end-to-end-type-safety\",\n    \"aria-label\": \"end to end type safety permalink\",\n    \"className\": \"anchor before\"\n  }, mdx(\"svg\", {\n    parentName: \"a\",\n    \"aria-hidden\": \"true\",\n    \"focusable\": \"false\",\n    \"height\": \"16\",\n    \"version\": \"1.1\",\n    \"viewBox\": \"0 0 16 16\",\n    \"width\": \"16\"\n  }, mdx(\"path\", {\n    parentName: \"svg\",\n    \"fillRule\": \"evenodd\",\n    \"d\": \"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"\n  }))), \"End-to-End Type Safety\"), mdx(\"p\", null, \"While building a GraphQL api, the most common tasks are:\"), mdx(\"ul\", null, mdx(\"li\", {\n    parentName: \"ul\"\n  }, \"Creating GraphQL types\"), mdx(\"li\", {\n    parentName: \"ul\"\n  }, \"Composing said GraphQL types to create more complex types\"), mdx(\"li\", {\n    parentName: \"ul\"\n  }, \"Implementing query & mutation resolvers that work on said types\"), mdx(\"li\", {\n    parentName: \"ul\"\n  }, \"Implementing field resolvers on the object types\")), mdx(\"p\", null, mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"uniform-graphql\"), \" is built with compile time type-safety front and center, making it very hard for you to experience type errors at runtime. You will find a simple, streamlined approach that will guide you end-to-end through the tasks listed above.\"), mdx(\"h2\", {\n    \"id\": \"non-null-first\",\n    \"style\": {\n      \"position\": \"relative\"\n    }\n  }, mdx(\"a\", {\n    parentName: \"h2\",\n    \"href\": \"#non-null-first\",\n    \"aria-label\": \"non null first permalink\",\n    \"className\": \"anchor before\"\n  }, mdx(\"svg\", {\n    parentName: \"a\",\n    \"aria-hidden\": \"true\",\n    \"focusable\": \"false\",\n    \"height\": \"16\",\n    \"version\": \"1.1\",\n    \"viewBox\": \"0 0 16 16\",\n    \"width\": \"16\"\n  }, mdx(\"path\", {\n    parentName: \"svg\",\n    \"fillRule\": \"evenodd\",\n    \"d\": \"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"\n  }))), \"Non-Null First\"), mdx(\"p\", null, \"In GraphQL, types are \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"null-first\"), \", which means they are nullable unless explicitly wrapped with a \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"GraphQLNonNull\"), \" type. In \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"TypeScript\"), \" on the other hand, types are \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"non-null-first\"), \": non-nullable by default unless they are explicitly made nullable. This tension is something that few code-first approaches acknowledge and solve for, which results in schema-code mismatches and general developer pain.\"), mdx(\"p\", null, \"In \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"uniform-graphql\"), \", we side with \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"TypeScript\"), \" when it comes to nullability, because we are a code-first library and we want to play nicely with our programming language. This is why everything is non-nullable unless they are explicitly made nullable.\"), mdx(\"pre\", null, mdx(\"code\", {\n    parentName: \"pre\",\n    \"className\": \"language-ts\"\n  }, \"/** Null-first: Things are nullable by default, unless explicitly made non-nullable */\\n\\nimport {\\n  GraphQLID,\\n  GraphQLNonNull,\\n  GraphQLObjectType,\\n  GraphQLString,\\n} from 'graphql';\\n\\nconst User = new GraphQLObjectType({\\n  name: 'User',\\n  fields: {\\n    id: { type: new GraphQLNonNull(GraphQLID) },\\n    fullName: { type: GraphQLString },\\n  },\\n});\\n\")), mdx(\"pre\", null, mdx(\"code\", {\n    parentName: \"pre\",\n    \"className\": \"language-ts\"\n  }, \"/** Non-null-first: Things are non-nullable by default, unless explicitly made nullable */\\n\\nimport { t } from '@whatsgood/uniform-graphql';\\n\\nconst User = t.object({\\n  name: 'User',\\n  fields: {\\n    id: t.id,\\n    fullName: t.string.nullable,\\n  },\\n});\\n\")), mdx(\"pre\", null, mdx(\"code\", {\n    parentName: \"pre\",\n    \"className\": \"language-graphql\"\n  }, \"# Both codes result with the same typedef:\\n\\ntype User {\\n  id: ID!\\n  fullName: String\\n}\\n\")), mdx(\"h2\", {\n    \"id\": \"composability\",\n    \"style\": {\n      \"position\": \"relative\"\n    }\n  }, mdx(\"a\", {\n    parentName: \"h2\",\n    \"href\": \"#composability\",\n    \"aria-label\": \"composability permalink\",\n    \"className\": \"anchor before\"\n  }, mdx(\"svg\", {\n    parentName: \"a\",\n    \"aria-hidden\": \"true\",\n    \"focusable\": \"false\",\n    \"height\": \"16\",\n    \"version\": \"1.1\",\n    \"viewBox\": \"0 0 16 16\",\n    \"width\": \"16\"\n  }, mdx(\"path\", {\n    parentName: \"svg\",\n    \"fillRule\": \"evenodd\",\n    \"d\": \"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"\n  }))), \"Composability\"), mdx(\"p\", null, \"One of GraphQL's main benefits is the reusability and composability of types. You can create an \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"enum\"), \" type, which you use in an \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"object\"), \" type, which you use in a \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"list\"), \" type, which you use in an \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"interface\"), \" type, which you use in another \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"object\"), \" type, which you use in a \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"union\"), \" type and so on.\"), mdx(\"p\", null, \"In \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"uniform-graphql\"), \", you are able to infinitely compose and reuse your types. This includes \", mdx(\"a\", {\n    parentName: \"p\",\n    \"href\": \"https://en.wikipedia.org/wiki/Recursive_data_type\"\n  }, \"self referential\"), \" and \", mdx(\"a\", {\n    parentName: \"p\",\n    \"href\": \"https://en.wikipedia.org/wiki/Recursive_data_type\"\n  }, \"mutually recursive\"), \" types, while always adhering to our core principle of end-to-end type safety. Keep on reading to see how we handle such use cases.\"), mdx(\"pre\", null, mdx(\"code\", {\n    parentName: \"pre\",\n    \"className\": \"language-graphql\"\n  }, \"# Self referential type\\ntype User {\\n  id: ID!\\n  friends: [User]! # type A refers to itself\\n}\\n\\n# Mutually recursive types\\n\\ntype Person {\\n  id: ID!\\n  pets: [Animal]! # type A refers to type B\\n}\\n\\ntype Animal {\\n  id: ID!\\n  owner: Person! # type B refers to type A\\n}\\n\")), mdx(\"h2\", {\n    \"id\": \"uniform-type-system\",\n    \"style\": {\n      \"position\": \"relative\"\n    }\n  }, mdx(\"a\", {\n    parentName: \"h2\",\n    \"href\": \"#uniform-type-system\",\n    \"aria-label\": \"uniform type system permalink\",\n    \"className\": \"anchor before\"\n  }, mdx(\"svg\", {\n    parentName: \"a\",\n    \"aria-hidden\": \"true\",\n    \"focusable\": \"false\",\n    \"height\": \"16\",\n    \"version\": \"1.1\",\n    \"viewBox\": \"0 0 16 16\",\n    \"width\": \"16\"\n  }, mdx(\"path\", {\n    parentName: \"svg\",\n    \"fillRule\": \"evenodd\",\n    \"d\": \"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"\n  }))), \"Uniform Type System\"), mdx(\"p\", null, \"No need to maintain two separate type systems for GraphQL and TypeScript while trying to keep them in sync. Once you create your \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"uniform\"), \" types, all will be taken care of. You will never need to manually type out function parameter types or return types. Everything is inferred from your \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"uniform\"), \" types; all you need to do is to fill in the blanks.\"), mdx(\"p\", null, mdx(\"img\", {\n    parentName: \"p\",\n    \"src\": \"https://i.ibb.co/Wvg8Mkp/autocomplete-enum.png\",\n    \"alt\": \"Code autocompletion for resolvers\"\n  })), mdx(\"p\", null, mdx(\"em\", {\n    parentName: \"p\"\n  }, \"Example 1\"), \": The compiler is complaining because the \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"resolve\"), \" function is incorrectly implemented. When we ask for hints on the \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"membership\"), \" field, we are shown that we need to return one of the listed type literals.\"), mdx(\"p\", null, mdx(\"img\", {\n    parentName: \"p\",\n    \"src\": \"https://i.ibb.co/BnzKQDW/inferred-args-type.png\",\n    \"alt\": \"Args types in TypeScript\"\n  })), mdx(\"p\", null, mdx(\"em\", {\n    parentName: \"p\"\n  }, \"Example 2\"), \": When we hover over \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"args.id\"), \", we see that it's a union type between \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"string\"), \" and \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"number\"), \". All this type information comes directly through the library. While developing our GraphQL api, we don't need to manually write any \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"TypeScript\"), \" types for our resolvers. This inclues the resolver function arguments and the return type.\"));\n}\n;\nMDXContent.isMDXComponent = true;","headings":[{"depth":2,"value":"Motivation"},{"depth":2,"value":"End-to-End Type Safety"},{"depth":2,"value":"Non-Null First"},{"depth":2,"value":"Composability"},{"depth":2,"value":"Uniform Type System"}]}},"pageContext":{"slug":"/why-uniform-graphql/","prev":{"label":"Introduction","link":"/"},"next":{"label":"Get Started","link":"/get-started"},"githubEditUrl":"https://github.com/whats-good/uniform-graphql/tree/master/packages/website/src/docs/why-uniform-graphql.mdx"}},"staticQueryHashes":["1954253342","2328931024","2501019404","973074209"]}