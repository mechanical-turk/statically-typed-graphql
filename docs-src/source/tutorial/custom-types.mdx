---
title: 'Custom Types'
sidebar_title: '1. Custom Types'
description: Learn how to create and use your own custom types
---

You might have noticed that we are using this `t.string` value to communicate the resolve type of our `hello` query. `Uniform GraphQL` ships with 5 built-in [scalars](/types/scalars) including `t.string`. Let's use them to improve upon our [Hello World](/tutorial/setup/#hello-world) example.

## Type Safety

```ts
//...

// This resolver has an error on purpose.
schemaBuilder.query('favoriteInteger', {
  type: t.int,
  resolve: () => {
    // Returning a String even though the resolve type is Int
    return '999';
  },
});

// ...
```

This resolver has an **error** on purpose. What do you see when you copy these lines to your `index.ts`?
What you've just witnessed is the simplest example of how `Uniform GraphQL` helps you with type safety:

![Type Safety First Example](/screenshots/string-to-number-type-mismatch.gif)

## Simple Scalars

```ts:title=src/index.ts
//...

schemaBuilder.query('favoriteInteger', {
  type: t.int,
  resolve: () => 999,
});

schemaBuilder.query('favoriteFloat', {
  type: t.float,
  resolve: () => 999.999,
});

schemaBuilder.query('isLearning', {
  type: t.boolean,
  resolve: () => true,
});

/**
 * GraphQL spec allows both string and
 * number values for the ID typedef.
 */

schemaBuilder.query('idExample', {
  type: t.id,
  resolve: () => 'string id',
});

schemaBuilder.query('anotherIdExample', {
  type: t.id,
  resolve: () => 15,
});

//...
```

Copy the lines above into your `index.ts` and navigate to your playground. Go ahead and send a query that covers your entire schema. If what you see matches the screenshot below, proceed to the next step.

![First Scalars](/screenshots/first-scalars.jpg)
