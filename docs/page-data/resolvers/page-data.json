{"componentChunkName":"component---node-modules-rocketseat-gatsby-theme-docs-core-src-templates-docs-query-js","path":"/resolvers","result":{"data":{"mdx":{"id":"088d3a56-d05f-533b-9afa-3b64416341df","excerpt":"Once you have all your uniform types, you can start building your query and mutation resolvers. Schema Builder Your first step here is initializing yourâ€¦","fields":{"slug":"/resolvers/"},"frontmatter":{"title":"Resolvers","description":"Learn how to get started with Rocket Docs.","image":null,"disableTableOfContents":null},"body":"function _extends() { _extends = Object.assign || function (target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i]; for (var key in source) { if (Object.prototype.hasOwnProperty.call(source, key)) { target[key] = source[key]; } } } return target; }; return _extends.apply(this, arguments); }\n\nfunction _objectWithoutProperties(source, excluded) { if (source == null) return {}; var target = _objectWithoutPropertiesLoose(source, excluded); var key, i; if (Object.getOwnPropertySymbols) { var sourceSymbolKeys = Object.getOwnPropertySymbols(source); for (i = 0; i < sourceSymbolKeys.length; i++) { key = sourceSymbolKeys[i]; if (excluded.indexOf(key) >= 0) continue; if (!Object.prototype.propertyIsEnumerable.call(source, key)) continue; target[key] = source[key]; } } return target; }\n\nfunction _objectWithoutPropertiesLoose(source, excluded) { if (source == null) return {}; var target = {}; var sourceKeys = Object.keys(source); var key, i; for (i = 0; i < sourceKeys.length; i++) { key = sourceKeys[i]; if (excluded.indexOf(key) >= 0) continue; target[key] = source[key]; } return target; }\n\n/* @jsxRuntime classic */\n\n/* @jsx mdx */\nvar _frontmatter = {\n  \"title\": \"Resolvers\",\n  \"description\": \"Learn how to get started with Rocket Docs.\"\n};\nvar layoutProps = {\n  _frontmatter: _frontmatter\n};\nvar MDXLayout = \"wrapper\";\nreturn function MDXContent(_ref) {\n  var components = _ref.components,\n      props = _objectWithoutProperties(_ref, [\"components\"]);\n\n  return mdx(MDXLayout, _extends({}, layoutProps, props, {\n    components: components,\n    mdxType: \"MDXLayout\"\n  }), mdx(\"p\", null, \"Once you have all your uniform types, you can start building your query and mutation resolvers.\"), mdx(\"h3\", {\n    \"id\": \"schema-builder\",\n    \"style\": {\n      \"position\": \"relative\"\n    }\n  }, mdx(\"a\", {\n    parentName: \"h3\",\n    \"href\": \"#schema-builder\",\n    \"aria-label\": \"schema builder permalink\",\n    \"className\": \"anchor before\"\n  }, mdx(\"svg\", {\n    parentName: \"a\",\n    \"aria-hidden\": \"true\",\n    \"focusable\": \"false\",\n    \"height\": \"16\",\n    \"version\": \"1.1\",\n    \"viewBox\": \"0 0 16 16\",\n    \"width\": \"16\"\n  }, mdx(\"path\", {\n    parentName: \"svg\",\n    \"fillRule\": \"evenodd\",\n    \"d\": \"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"\n  }))), \"Schema Builder\"), mdx(\"p\", null, \"Your first step here is initializing your \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"SchemaBuilder\"), \". This is the object that will stitch all your resolvers and types together to finally give you a \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"GraphQLSchema\"), \", which you can use in any way you want.\"), mdx(\"p\", null, \"You can initialize your schema builder with a generic type for the GraphQLContext object. In the example below, the context has a \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"currentUser\"), \" object.\"), mdx(\"pre\", null, mdx(\"code\", {\n    parentName: \"pre\",\n    \"className\": \"language-ts\"\n  }, \"import { t, SchemaBuilder } from '@whatsgood/uniform-graphql';\\n\\ntype MyGraphQLContext = {\\n  currentUser?: {\\n    id: string;\\n    email: string;\\n  };\\n};\\n\\nconst schemaBuilder = new SchameBuilder<MyGraphQLContext>();\\n\")), mdx(\"h3\", {\n    \"id\": \"your-first-query-resolver\",\n    \"style\": {\n      \"position\": \"relative\"\n    }\n  }, mdx(\"a\", {\n    parentName: \"h3\",\n    \"href\": \"#your-first-query-resolver\",\n    \"aria-label\": \"your first query resolver permalink\",\n    \"className\": \"anchor before\"\n  }, mdx(\"svg\", {\n    parentName: \"a\",\n    \"aria-hidden\": \"true\",\n    \"focusable\": \"false\",\n    \"height\": \"16\",\n    \"version\": \"1.1\",\n    \"viewBox\": \"0 0 16 16\",\n    \"width\": \"16\"\n  }, mdx(\"path\", {\n    parentName: \"svg\",\n    \"fillRule\": \"evenodd\",\n    \"d\": \"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"\n  }))), \"Your First Query Resolver\"), mdx(\"p\", null, \"Once you have your \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"SchemaBuilder\"), \", you can start building queries and mutations. You will use the uniform types you've built. The library will guide you and help you with what you are allowed to return from your resolvers, how you can use the arguments, and the GraphQL context object.\"), mdx(\"p\", null, \"Let\\u2019s begin with a simple example: A resolver that simply returns the number \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"100\"), \".\"), mdx(\"pre\", null, mdx(\"code\", {\n    parentName: \"pre\",\n    \"className\": \"language-ts\"\n  }, \"schemaBuilder.query('oneHundred', {\\n  type: t.int,\\n  resolve: () => {\\n    return 100;\\n  },\\n});\\n\")), mdx(\"p\", null, \"If we served \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"schemaBuilder.getSchema()\"), \", we would get a fully functional GraphQL Api with the following typedefs:\"), mdx(\"pre\", null, mdx(\"code\", {\n    parentName: \"pre\",\n    \"className\": \"language-graphql\"\n  }, \"type Query {\\n  oneHundred: Int!\\n}\\n\")), mdx(\"h3\", {\n    \"id\": \"arguments\",\n    \"style\": {\n      \"position\": \"relative\"\n    }\n  }, mdx(\"a\", {\n    parentName: \"h3\",\n    \"href\": \"#arguments\",\n    \"aria-label\": \"arguments permalink\",\n    \"className\": \"anchor before\"\n  }, mdx(\"svg\", {\n    parentName: \"a\",\n    \"aria-hidden\": \"true\",\n    \"focusable\": \"false\",\n    \"height\": \"16\",\n    \"version\": \"1.1\",\n    \"viewBox\": \"0 0 16 16\",\n    \"width\": \"16\"\n  }, mdx(\"path\", {\n    parentName: \"svg\",\n    \"fillRule\": \"evenodd\",\n    \"d\": \"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"\n  }))), \"Arguments\"), mdx(\"p\", null, \"Resolvers become more interesting when they change their behaviors based on user input. Here's a simple example with arguments:\"), mdx(\"pre\", null, mdx(\"code\", {\n    parentName: \"pre\",\n    \"className\": \"language-ts\"\n  }, \"schemaBuilder.query('ping', {\\n  type: t.string,\\n  args: { myNumber: t.int },\\n  resolve: (_, args) => {\\n    return `Your number is: ${args.myNumber}`;\\n  },\\n});\\n\")), mdx(\"p\", null, \"Here we have a resolver that returns a string, based on the integer input of its user. The library will make sure that all arguments passed and all resolver return types match exactly to the uniform types. For example, these would be invalid.\"), mdx(\"pre\", null, mdx(\"code\", {\n    parentName: \"pre\",\n    \"className\": \"language-ts\"\n  }, \"/** Invalid resolver example: 1 */\\nschemaBuilder.query('ping', {\\n  type: t.string,\\n  args: { myNumber: t.int },\\n  resolve: (_, args) => {\\n    return `Your number is: ${args.someOtherNumber}`; // using an arg that doesnt exist\\n  },\\n});\\n\\n/** Invalid resolver example: 2 */\\nschemaBuilder.query('ping', {\\n  type: t.string,\\n  args: { myNumber: t.int },\\n  resolve: (_, args) => {\\n    return 100; // returning a number for a string type\\n  },\\n});\\n\\n/** Invalid resolver example: 3 */\\nschemaBuilder.query('ping', {\\n  type: t.string,\\n  args: { myNumber: t.int },\\n  resolve: (_, args) => {\\n    const a = args.myNumber.length; // args.myNumber is of type number, where .length doesnt exist\\n  },\\n});\\n\")), mdx(\"h3\", {\n    \"id\": \"async-resolvers\",\n    \"style\": {\n      \"position\": \"relative\"\n    }\n  }, mdx(\"a\", {\n    parentName: \"h3\",\n    \"href\": \"#async-resolvers\",\n    \"aria-label\": \"async resolvers permalink\",\n    \"className\": \"anchor before\"\n  }, mdx(\"svg\", {\n    parentName: \"a\",\n    \"aria-hidden\": \"true\",\n    \"focusable\": \"false\",\n    \"height\": \"16\",\n    \"version\": \"1.1\",\n    \"viewBox\": \"0 0 16 16\",\n    \"width\": \"16\"\n  }, mdx(\"path\", {\n    parentName: \"svg\",\n    \"fillRule\": \"evenodd\",\n    \"d\": \"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"\n  }))), \"Async Resolvers\"), mdx(\"p\", null, mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"uniform-graphql\"), \" allows async resolvers for any and all types. For example:\"), mdx(\"pre\", null, mdx(\"code\", {\n    parentName: \"pre\",\n    \"className\": \"language-ts\"\n  }, \"//...\\n\\nschemaBuilder.query('numLoggedInUsers', {\\n  type: t.int,\\n  args: { myNumber: t.int },\\n  resolve: async (_, args) => {\\n    return usersStore.getNumLoggedInUsers(); // some way of accessing a database\\n  },\\n});\\n\")), mdx(\"h3\", {\n    \"id\": \"resolving-object-types\",\n    \"style\": {\n      \"position\": \"relative\"\n    }\n  }, mdx(\"a\", {\n    parentName: \"h3\",\n    \"href\": \"#resolving-object-types\",\n    \"aria-label\": \"resolving object types permalink\",\n    \"className\": \"anchor before\"\n  }, mdx(\"svg\", {\n    parentName: \"a\",\n    \"aria-hidden\": \"true\",\n    \"focusable\": \"false\",\n    \"height\": \"16\",\n    \"version\": \"1.1\",\n    \"viewBox\": \"0 0 16 16\",\n    \"width\": \"16\"\n  }, mdx(\"path\", {\n    parentName: \"svg\",\n    \"fillRule\": \"evenodd\",\n    \"d\": \"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"\n  }))), \"Resolving Object Types\"), mdx(\"p\", null, \"GraphQL provides a ton of flexibility when it comes to resolving object types. We can enjoy all this flexibility in a completely typesafe manner. Let\\u2019s begin with a \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"User\"), \" type:\"), mdx(\"pre\", null, mdx(\"code\", {\n    parentName: \"pre\",\n    \"className\": \"language-ts\"\n  }, \"//...\\n\\nconst User = t.object({\\n  name: 'User',\\n  fields: {\\n    id: t.id,\\n    fullName: t.string.nullable,\\n    expensiveField: t.string,\\n    // This field is expensive to pull from the DB.\\n    // If possible, we\\u2019d like to avoid pulling it.\\n  },\\n});\\n\\nschemaBuilder.query('user', {\\n  type: User,\\n  args: { id: t.id },\\n  resolve: async (_, args) => {\\n    const user = await usersStore.findById(args.id);\\n    const expensiveThing = await expensiveThingsStore.findByUserId(args.id);\\n    return {\\n      id: user.id,\\n      fullName: user.fullName,\\n      expensiveField: expensiveThing,\\n    };\\n  },\\n});\\n\")), mdx(\"p\", null, \"While this resolver is correctly implemented, it will always pull the \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"expensive\"), \" field, even if the end-user doesn\\u2019t request it. In scenarios like this, we can use \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"GraphQL\"), \"'s deferred resolution feature to avoid doing unnecessary computations. We will harness the power of \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"thunks\"), \". A \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"thunk\"), \" is a function with no parameters, but once called, it will return some wrapped value:\"), mdx(\"pre\", null, mdx(\"code\", {\n    parentName: \"pre\",\n    \"className\": \"language-ts\"\n  }, \"//...\\n\\nschemaBuilder.query('user', {\\n  type: User,\\n  args: { id: t.id },\\n  resolve: async (_, args) => {\\n    const usersStore = new UsersStore();\\n    const expensiveThingsStore = new ExpensiveThingsStore();\\n    const user = await usersStore.findById(args.id);\\n    return {\\n      id: user.id,\\n      fullName: user.fullName,\\n      expensiveField: async () => {\\n        /**\\n         * here, we're deferring the computation of\\n         * \\\"expensiveField\\\" through an async thunk, so\\n         * that it\\u2019s only computed when it's necessary.\\n         */\\n        return expensiveThingsStore.findByUserId(args.id);\\n      },\\n    };\\n  },\\n});\\n\")), mdx(\"h3\", {\n    \"id\": \"resolve-function-return-types\",\n    \"style\": {\n      \"position\": \"relative\"\n    }\n  }, mdx(\"a\", {\n    parentName: \"h3\",\n    \"href\": \"#resolve-function-return-types\",\n    \"aria-label\": \"resolve function return types permalink\",\n    \"className\": \"anchor before\"\n  }, mdx(\"svg\", {\n    parentName: \"a\",\n    \"aria-hidden\": \"true\",\n    \"focusable\": \"false\",\n    \"height\": \"16\",\n    \"version\": \"1.1\",\n    \"viewBox\": \"0 0 16 16\",\n    \"width\": \"16\"\n  }, mdx(\"path\", {\n    parentName: \"svg\",\n    \"fillRule\": \"evenodd\",\n    \"d\": \"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"\n  }))), \"Resolve Function Return Types\"), mdx(\"p\", null, \"GraphQL resolve function return types are pretty complex. Let\\u2019s go over a few steps to understand how they work. We will attempt to understand the return type of our resolve function for the \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"\\\"user\\\"\"), \" query from above. We will start simple and gradually arrive at the correct type:\"), mdx(\"pre\", null, mdx(\"code\", {\n    parentName: \"pre\",\n    \"className\": \"language-ts\"\n  }, \"type Promisable<T> = T | Promise<T>; // represents T when it may or may not be wrapped in a promise\\n\\ntype Thunk<T> = () => T; // a thunk is a no-param function that wraps a value\\n\\ntype Thunkable<T> = T | Thunk<T>; // represents T when it may or may not be wrapped inside a thunk\\n\\n// Let\\u2019s start with a simple attempt:\\ntype T1 = {\\n  id: string | number;\\n  fullName?: string | null | undefined;\\n  expensiveField: string;\\n};\\n\\n// This is a slightly more sophisticated type that acknowledges that the result may or may not be a promise\\ntype T2 = Promisable<{\\n  id: string | number;\\n  fullName?: string | null | undefined;\\n  expensiveField: string;\\n}>;\\n\\n// Almost there. We now cover how the object fields may or may not be thunks\\ntype T3 = Promisable<{\\n  id: Thunkable<string | number>;\\n  fullName?: Thunkable<string | null | undefined>;\\n  expensiveField: Thunkable<string>;\\n}>;\\n\\n// All thunks may or may not return promises. With that, we have the fully realized return type for our resolver\\ntype T4 = Promisable<{\\n  id: Thunkable<Promisable<string | number>>;\\n  fullName?: Thunkable<Promisable<string | null | undefined>>;\\n  expensiveField: Thunkable<Promisable<string>>;\\n}>;\\n\")), mdx(\"blockquote\", null, mdx(\"p\", {\n    parentName: \"blockquote\"\n  }, \"As you can see, there are many ways to resolve the same type. Luckily, you will \", mdx(\"strong\", {\n    parentName: \"p\"\n  }, \"never\"), \" have to write out these types by hand. In fact, you will \", mdx(\"strong\", {\n    parentName: \"p\"\n  }, \"never\"), \" need to write out any types while coding your resolvers. All will be automatically derived from your \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"uniform\"), \" types.\")));\n}\n;\nMDXContent.isMDXComponent = true;","headings":[{"depth":3,"value":"Schema Builder"},{"depth":3,"value":"Your First Query Resolver"},{"depth":3,"value":"Arguments"},{"depth":3,"value":"Async Resolvers"},{"depth":3,"value":"Resolving Object Types"},{"depth":3,"value":"Resolve Function Return Types"}]}},"pageContext":{"slug":"/resolvers/","prev":{"label":"Get Started","link":"/get-started"},"next":{"label":"Scalars","link":"/types/scalars"},"githubEditUrl":"https://github.com/whats-good/uniform-graphql/tree/master/packages/website/src/docs/resolvers.mdx"}},"staticQueryHashes":["1954253342","2328931024","2501019404","973074209"]}